$date
	Thu May 16 23:55:18 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module MAS16bA_tb $end
$var wire 1 ! dgnd $end
$var wire 1 " dvdd $end
$var reg 1 # clk $end
$var reg 16 $ instr [15:0] $end
$var reg 1 % pg $end
$var reg 1 & rstz $end
$scope module uut $end
$var wire 1 # clk $end
$var wire 1 ! dgnd $end
$var wire 1 " dvdd $end
$var wire 16 ' instrAddr [15:0] $end
$var wire 1 % pg $end
$var wire 16 ( pg_instr [15:0] $end
$var wire 1 & rstz $end
$var wire 16 ) wbdata [15:0] $end
$var wire 2 * type [1:0] $end
$var wire 1 + selB $end
$var wire 1 , rfen $end
$var wire 2 - rd [1:0] $end
$var wire 2 . rb [1:0] $end
$var wire 2 / ra [1:0] $end
$var wire 16 0 opd [15:0] $end
$var wire 16 1 opc [15:0] $end
$var wire 16 2 opb_alu [15:0] $end
$var wire 16 3 opb [15:0] $end
$var wire 16 4 opa [15:0] $end
$var wire 2 5 op [1:0] $end
$var wire 1 6 mwen $end
$var wire 1 7 msel $end
$var wire 16 8 mem_out [15:0] $end
$var wire 1 9 jsel $end
$var wire 16 : instr [15:0] $end
$var wire 1 ; cbz_flag $end
$var wire 8 < c [7:0] $end
$var wire 16 = alu_res [15:0] $end
$var reg 16 > pc [15:0] $end
$scope module alu $end
$var wire 1 ! dgnd $end
$var wire 1 " dvdd $end
$var wire 16 ? opB [15:0] $end
$var wire 16 @ rand [15:0] $end
$var wire 16 A rnot [15:0] $end
$var wire 16 B ror [15:0] $end
$var wire 16 C rset [15:0] $end
$var wire 16 D rxor [15:0] $end
$var wire 2 E selType [1:0] $end
$var wire 2 F selOp [1:0] $end
$var wire 16 G rsra [15:0] $end
$var wire 16 H rmul [15:0] $end
$var wire 16 I rmem [15:0] $end
$var wire 16 J rlt [15:0] $end
$var wire 16 K rlog [15:0] $end
$var wire 16 L res [15:0] $end
$var wire 16 M rcnd [15:0] $end
$var wire 16 N rbj [15:0] $end
$var wire 16 O ratm [15:0] $end
$var wire 16 P radr [15:0] $end
$var wire 16 Q radd [15:0] $end
$var wire 16 R opD [15:0] $end
$var wire 16 S opA [15:0] $end
$var wire 1 ; cbz $end
$upscope $end
$scope module id $end
$var wire 1 # clk $end
$var wire 1 ! dgnd $end
$var wire 1 " dvdd $end
$var wire 1 , rfen $end
$var wire 1 + selB $end
$var wire 2 T selType [1:0] $end
$var wire 2 U selOp [1:0] $end
$var wire 2 V rd [1:0] $end
$var wire 2 W rb [1:0] $end
$var wire 2 X ra [1:0] $end
$var wire 4 Y opcode [3:0] $end
$var wire 1 7 msel $end
$var wire 1 6 memwen $end
$var wire 1 9 jsel $end
$var wire 16 Z instr [15:0] $end
$var wire 8 [ c [7:0] $end
$upscope $end
$scope module mem $end
$var wire 16 \ addressA [15:0] $end
$var wire 16 ] addressB [15:0] $end
$var wire 16 ^ dataInA [15:0] $end
$var wire 1 ! dgnd $end
$var wire 1 " dvdd $end
$var wire 1 % writeEnableA $end
$var wire 1 6 writeEnableB $end
$var wire 16 _ nextAddrB [15:0] $end
$var wire 16 ` nextAddrA [15:0] $end
$var wire 16 a dataOutB [15:0] $end
$var wire 16 b dataOutA [15:0] $end
$var wire 16 c dataInB [15:0] $end
$upscope $end
$scope module rf $end
$var wire 1 # clk $end
$var wire 16 d data [15:0] $end
$var wire 1 ! dgnd $end
$var wire 1 " dvdd $end
$var wire 1 , en $end
$var wire 2 e ra [1:0] $end
$var wire 2 f rb [1:0] $end
$var wire 2 g rd [1:0] $end
$var wire 1 & rstz $end
$var wire 16 h opD [15:0] $end
$var wire 16 i opB [15:0] $end
$var wire 16 j opA [15:0] $end
$var parameter 32 k NREGISTERS $end
$var parameter 32 l WIDTH $end
$scope begin $ivl_for_loop0 $end
$var integer 32 m i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10000 l
b100 k
$end
#0
$dumpvars
bx m
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
b0x J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
x;
bx :
x9
bx 8
x7
x6
bx 5
bx 4
bx 3
bx 2
b0xxxxxxxx 1
bx 0
bx /
bx .
bx -
x,
x+
bx *
bx )
bx (
bz '
x&
x%
bx $
0#
z"
z!
$end
